"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RepeatMode = exports.MediaState = exports.CustomNativeEventTypes = exports.AudioOutput = exports.ActionTypes = void 0;
exports.Track = Track;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * This contains all data needed for a song
 * @constructor
 * @param {!string} trackID - Unique identifier used in sorting after shuffle
 * @param {!string} coverArt -  URL to cover art image
 * @param {!string} title
 * @param {!string} artist
 * @param {!string} source - URL to music file
 */
function Track(trackID, coverArt, title, artist, source) {
  /** @readonly*/
  this.ID = trackID;
  /** @readonly*/

  this.coverArt = coverArt;
  /**@readonly */

  this.title = title;
  /**@readonly */

  this.artist = artist;
  /** @readonly*/

  this.source = source;

  this.getSource = function () {
    return source;
  };
}
/**
 * @typedef {object} State - State object
 * @prop {MediaState} mediaState - Media state
 * @prop {number} currentTrack - Current time in seconds
 * @prop {boolean} shuffled - Boolean representation of whether playlist is shuffled or not
 * @prop {Array<Track>} playlist - Array of tracks supplied to player
 * @prop {number} currentTime - Current progress in seconds
 * @prop {number}  timeLeft - Time left to end play in seconds
 * @prop {number} volume - Volme level
 * @prop {RepeatMode} repeatMode - Repeat mode
 */

/**
 * Media states
 * @enum {string}
 */


var MediaState = {
  STOPPED: "STOPPED",
  PLAYING: "PLAYING",
  PAUSED: "PAUSED"
};
/**
 * Repeat modes
 * @enum {string}
 */

exports.MediaState = MediaState;
var RepeatMode = {
  NORMAL: "NORMAL",
  REPEAT_ALL: "REPEAT_ALL",
  REPEAT_ONE: "REPEAT_ONE"
};
/**
 * Custom native events for module level interface
 * @enum {string}
 */

exports.RepeatMode = RepeatMode;
var CustomNativeEventTypes = {
  PLAY: "PLAY",
  PAUSE: "PAUSE",
  STOP: "STOP",
  SET_VOLUME: "SET_VOLUME",
  SKIP_NEXT: "SKIP_NEXT",
  SKIP_PREV: "SKIP_PREV",
  SHUFFLE: "SHUFFLE",
  SEEK: "SEEK",
  SET_REPEAT_MODE: "SET_REPEAT_MODE",
  CHANGE_TRACK: "CHANGE_TRACK",
  PLAY_LATER: "PLAY_LATER",
  PLAY_NEXT: "PLAY_NEXT",
  SET_PLAYLIST: "SET_PLAYLIST",
  CLEAR_PLAYLIST: "CLEAR_PLAYLIST"
};
/** Call back for useSelect hook
 * @callback useSelectCb
 * @param {State} state
 */

/**
 * Audio output model
 * @class
 * @extends {Audio}
 */

exports.CustomNativeEventTypes = CustomNativeEventTypes;

var AudioOutput = /*#__PURE__*/function (_Audio) {
  _inherits(AudioOutput, _Audio);

  var _super = _createSuper(AudioOutput);

  function AudioOutput() {
    var _this;

    _classCallCheck(this, AudioOutput);

    _this = _super.call(this);
    /**@private */

    _this.track = new Track("", "", "", "", ""); // default track

    return _this;
  }
  /**
   * Sets source of audio
   * @param {Track} track
   */


  _createClass(AudioOutput, [{
    key: "setSrc",
    value: function setSrc(track) {
      if (track === undefined) return;

      if (!this.isCurrent(track)) {
        this.src = track.source;
        this.track = track;
        this.setMediaMetadata(track);
      }
    }
  }, {
    key: "setMediaMetadata",
    value: function setMediaMetadata(track) {
      if ("mediaSession" in navigator) {
        if (!track) navigator.mediaSession.metadata = null;else navigator.mediaSession.metadata = new window.MediaMetadata({
          title: track.title,
          artist: track.artist,
          album: "",
          artwork: [{
            src: track.coverArt
          }]
        });
      }
    }
    /**
     * Unsets audio can be used to stop play
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this.src === "") return;
      this.setSrc(new Track("", "", "", "", ""));
      this.setMediaMetadata(null);
    }
    /**
     * Check if same track loaded
     * @param {Track} track
     * @returns {boolean}
     */

  }, {
    key: "isCurrent",
    value: function isCurrent(track) {
      return this.track.ID === track.ID;
    }
  }]);

  return AudioOutput;
}( /*#__PURE__*/_wrapNativeSuper(Audio));
/**
 * Store action types
 * @enum {string}
 */


exports.AudioOutput = AudioOutput;
var ActionTypes = {
  CHANGE_TRACK: "CHANGE_TRACK",
  PLAY: "PLAY",
  PAUSE: "PAUSE",
  STOP: "STOP",
  SHUFFLE: "SHUFFLE",
  UPDATE_PLAYLIST: "UPDATE_PLAYLIST",
  CHANGE_VOLUME: "CHANGE_VOLUME",
  SET_START_TIME: "SET_START_TIME",
  SET_STOP_TIME: "SET_STOP_TIME",
  SET_CURRENT_TIME: "SET_CURRENT_TIME",
  SET_TIME_LEFT: "SET_TIME_LEFT",
  SEEK: "SEEK",
  SET_REPEAT_MODE: "SET_REPEAT_MODE",
  SKIP_NEXT: "SKIP_NEXT",
  SKIP_PREV: "SKIP_PREV"
};
exports.ActionTypes = ActionTypes;